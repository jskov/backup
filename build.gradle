plugins {
    id 'eclipse'
    id 'jacoco'
    id 'java'
    id 'com.github.johnrengelman.shadow' version '8.1.1'

    id 'dk.mada.style' version '1.0.3'
    id 'dk.mada.reproducible' version '1.0.2'
}

interface InjectedExecOps {
    @Inject //@javax.inject.Inject
    ExecOperations getExecOps()
}

group "${groupId}"

repositories {
    repositories {
        maven { url = uri("https://plugins.gradle.org/m2/") }
    }
    mavenCentral()
}

ext {
    successMarker = project.file("build/all-tests-passed")
    builtOn = LocalDateTime.now()
                .atZone(ZoneId.of('Europe/Copenhagen'))
                .withNano(0)
    testGpgHome = project.file("build/actions-gpg-home")
}

dependencies {
    implementation     (libs.compress)
    implementation     (libs.hash4j)
    implementation     (libs.picocli)
    implementation     (libs.slf4j)

    compileOnly        (libs.jspecify)

    testImplementation (libs.bundles.testUnit)
}

tasks.register('makeActionsDockerImage') {
    def injected = project.objects.newInstance(InjectedExecOps)
    doFirst {
        copy {
            into "build/actions-docker"
            from "src/actions"
            from ("src/test/data/gpghome") {
                include "*.asc"
            }
        }
        injected.execOps.exec {
            commandLine("podman", "build", "-t", "actions-backup", "build/actions-docker")
        }
    }
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
    
    withJavadocJar()
    withSourcesJar()
}

tasks.named('compileJava').configure {
    options.encoding = 'UTF-8'
    options.compilerArgs << '-parameters'
}

tasks.named('compileTestJava').configure {
    options.encoding = 'UTF-8'
}

tasks.named('processResources').configure {
    inputs.property("version", project.version)
    inputs.property("builtOn", builtOn)

    filesMatching("**/backup-version.properties") {
        filter(s -> s
            .replaceAll("version.*", "version = ${project.version}")
            .replaceAll("builtOn.*", "builtOn = ${builtOn}")
        )
    }
}

tasks.register('prepareActionsGpgTestHome') {
    def injected = project.objects.newInstance(InjectedExecOps)

    doFirst {
        project.mkdir(testGpgHome)
        injected.execOps.exec {
            commandLine("chmod", "og-rxw",testGpgHome)
        }
        injected.execOps.exec {
            commandLine("gpg", "--homedir", testGpgHome, "--import", "src/test/data/gpghome/exported-secret-key.asc")
        }
        injected.execOps.exec {
            commandLine("gpg", "--homedir", testGpgHome, "--import-ownertrust", "src/test/data/gpghome/exported-owner-trust.asc")
        }
    }
}

tasks.register('makeSuccessMarker') {
    doFirst {
        project.mkdir("build")
        successMarker.createNewFile()
    }
}

tasks.named('test').configure {
    dependsOn(makeSuccessMarker)
    dependsOn(prepareActionsGpgTestHome)
    useJUnitPlatform {
        excludeTags "accept"
    }  
    ignoreFailures = true

    testLogging.showStandardStreams = false

    afterTest { td, tr ->
        if (tr.resultType == org.gradle.api.tasks.testing.TestResult.ResultType.FAILURE) {
            successMarker.delete()
        }
    }
}

tasks.register('acceptTest', Test) {
    shouldRunAfter(test)
    dependsOn(makeSuccessMarker)
    dependsOn(prepareActionsGpgTestHome)

    testClassesDirs = testing.suites.test.sources.output.classesDirs
    classpath = testing.suites.test.sources.runtimeClasspath

    useJUnitPlatform {
        includeTags "accept"
    }
    ignoreFailures = true

    testLogging.showStandardStreams = true

    afterTest { td, tr ->
        if (tr.resultType == org.gradle.api.tasks.testing.TestResult.ResultType.FAILURE) {
            successMarker.delete()
        }
    }
}

tasks.named('check').configure {
    dependsOn(acceptTest)
    finalizedBy jacocoTestReport // report is always generated after tests run
    doLast {
        if (!successMarker.exists()) {
            throw new IllegalStateException("Tests failed")
        }
    }
}

tasks.register('preCommit') {
    dependsOn('check')
    dependsOn('javadoc')
}

tasks.named('jacocoTestReport').configure {
    reports {
        xml.required.set(true)
    }
    dependsOn acceptTest // tests are required to run before generating the report
}

tasks.named('jar').configure {
    manifest {
        attributes(
            'Git-Hash' : (System.getenv('BUILD_SOURCEVERSION') ?: "no-version"),
            'Implementation-Version' : project.version,
            'Main-Class' : "dk.mada.backup.cli.CliMain"
        )
    }
    archiveBaseName = "backup"
}

tasks.named('shadowJar').configure {
    archiveClassifier = ""
    archiveFileName = "backup-shadow.jar"
}

tasks.named('clean').configure { delete("dist") }

tasks.named('eclipseClasspath').configure {
    dependsOn('cleanEclipseClasspath')
}


tasks.register('buildNative', Exec) {
    dependsOn('jar')
    doFirst {
        project.delete("build/backup")
    }
    commandLine 'native-image', '-cp', sourceSets.main.getRuntimeClasspath().getAsPath(), "dk.mada.backup.cli.CliMain", "build/backup"
}
